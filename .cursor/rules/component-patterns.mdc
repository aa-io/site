---
description:
globs:
alwaysApply: false
---
# Component Patterns & Best Practices

## Layout Components
- **Root Layout**: [app/layout.tsx](mdc:app/layout.tsx) - Global layout with sidebar and theme provider
- **Pages Layout**: [app/(pages)/layout.tsx](mdc:app/(pages)/layout.tsx) - Nested layout for content pages
- **Sidebar**: [components/app-sidebar.tsx](mdc:components/app-sidebar.tsx) - Main navigation component

## UI Component Architecture
Follow the shadcn/ui patterns established in [components/ui/](mdc:components/ui/):

### Button Component Pattern
```typescript
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link'
  size?: 'default' | 'sm' | 'lg' | 'icon'
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'default', size = 'default', ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
```

### Compound Component Pattern
Use compound components for complex UI like the sidebar system:
- `Sidebar` - Main container
- `SidebarContent` - Content wrapper
- `SidebarGroup` - Grouping sections
- `SidebarMenuItem` - Individual items

## Styling Patterns
- Use `cn()` utility function for conditional classes
- Leverage Tailwind's design tokens and CSS variables
- Follow the established color scheme: `--background`, `--foreground`, `--muted`
- Use semantic spacing: `--spacing` custom property

## State Management
- Use React's built-in state for component-level state
- Context providers for theme and sidebar state
- No external state management library currently used

## Accessibility Guidelines
- Use Radix UI primitives for accessible components
- Implement proper ARIA attributes
- Ensure keyboard navigation works correctly
- Follow semantic HTML structure

## Performance Patterns
- Use `React.forwardRef` for ref forwarding
- Implement proper memoization when needed
- Lazy load components when appropriate
- Optimize bundle size with tree-shaking
